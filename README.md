# SQL

#### Создаем таблицу
```
CREATE TABLE months (id int, name varchar(10), days int);
```

#### Ввод данных
```
INSERT INTO months VALUES (1,'January',31);
INSERT INTO months (id,name,days) VALUES (2,'February',29);
```
#### Select
```
SELECT name, weapon FROM characters
SELECT name, weapon FROM characters ORDER BY name DESC
```
#### Where
```
SELECT * 
FROM characters
WHERE weapon = 'pistol';
```
#### И/или
```
SELECT * 
FROM albums 
WHERE genre = 'rock' AND sales_in_millions <= 50 
ORDER BY released
```
#### In/Between/Like
##### Условия в WHERE могут быть записаны с использованием ещё нескольких команд, которыми являются:

    IN - сравнивает значение в столбце с несколькими возможными значениями и возвращает true, если значение совпадает хотя бы с одним значением
    BETWEEN - проверяет, находится ли значение в каком-то промежутке
    LIKE - ищет по шаблону

К примеру, мы можем сделать запрос для вывода данных об альбомах в жанре pop или soul:
```
SELECT * FROM albums WHERE genre IN ('pop','soul');
```
 Если мы хотим вывести все альбомы, которые были выпущены в промежутке между 1975 и 1985 годом, мы можем использовать следующую запись:
```
SELECT * FROM albums WHERE released BETWEEN 1975 AND 1985;
```

Также, если мы хотим вывести все альбомы, в названии которых есть буква 'R', мы можем использовать следующую запись:
```
SELECT * FROM albums WHERE album LIKE '%R%';
```
Знак % означает любую последовательность символов (0 символов тоже считается за последовательность).

Если мы хотим вывести все альбомы, первая буква в названии которых - 'R', то запись слегка изменится:
```
SELECT * FROM albums WHERE album LIKE 'R%';
```
В SQL также есть инверсия. Для примера, попробуйте самостоятельно написать NOT перед любым логическим выражением в условии (NOT BETWEEN и так далее).


#### Функции

В SQL полно встроенных функций для выполнения разных операций. Мы же покажем вам только наиболее часто используемые:

    COUNT() - возвращает число строк
    SUM() - возвращает сумму всех полей с числовыми значениями в них
    AVG() - возвращает среднее значение среди строк
    MIN()/MAX() - возвращает минимальное/максимальное значение среди строк

Чтобы вывести год выпуска самого старого альбома, в таблице можно использовать следующий запрос:
```
SELECT MIN(released) FROM albums;
```
Обратите внимание, что если вы напишете запрос, в котором вам, к примеру, нужно будет вывести имя и среднее значение чего-либо, то вы получите ошибку на выводе.

Допустим, вы пишете такой запрос:
```
SELECT name, avg(age) FROM students;
```
Чтобы избежать ошибки, вам следует добавить следующую строку:
```
GROUP BY name
```
Причиной тому является, что запись avg(age) является совокупной (aggregated), и вам необходимо группировать значения по имени.


#### Вложенные Select

В предыдущих шагах мы изучили, как делать простые вычисления с данными. Если мы хотим использовать результат данных вычислений, то часто нам необходимо использовать так называемые вложенные запросы. Допустим, нам необходимо вывести артиста, альбом и год выпуска самого старого альбома в таблице.

Вывести эти столбцы можно, используя следующий запрос:
```
SELECT artist, album, released FROM albums;
```
Также мы знаем, как получить самый ранний год из имеющихся:
```
SELECT MIN(released) FROM album;
```
Объединить эти запросы можно в WHERE:
```
SELECT artist,album,released 
FROM albums 
WHERE released = (
 SELECT MIN(released) FROM albums
);
```

#### Присоединение таблиц

В сложных базах данных чаще всего у нас есть несколько связанных таблиц. К примеру, у нас есть две таблицы: про видеоигры и про разработчиков.

В таблице video_games есть столбец developer_id, в данном случае он является так называемым foreign_key. Чтобы было проще понять, developer_id - это связывающее звено между двумя таблицами.

Если мы хотим вывести всю информацию об игре, включая информацию о её разработчике, нам необходимо подключить вторую таблицу. Чтобы это сделать, можно использовать INNER JOIN:
```
SELECT video_games.name, video_games.genre, game_developers.name, game_developers.country 
FROM video_games 
INNER JOIN game_developers 
ON video_games.developer_id = game_developers.id;
```
Это, наверное, самый простой пример использования JOIN. Есть ещё несколько вариантов его использования. Для более подробной информации предлагаем перейти по этой ссылке.

#### Псевлонимы

Если вы взгляните на предыдущий пример, то вы заметите, что есть два столбца, названных одинаково: "name". Часто это может запутать. Решением данной проблемы являются псевдонимы. Они, к слову, помогают сделать название столбца красивее или понятнее в случае необходимости.

Чтобы присвоить столбцу псевдоним, можно использовать ключевое слово AS:
```
SELECT games.name, games.genre, devs.name AS developer, devs.country 
FROM video_games AS games 
INNER JOIN game_developers AS devs 
ON games.developer_id = devs.id;
```

#### Update

Зачастую нам нужно изменить данные в таблице. В SQL это делается с помощью UPDATE.

Использование UPDATE включает в себя:

    выбор таблицы, в которой находится поле, которое мы хотим изменить
    запись нового значения
    использование WHERE, чтобы обозначить конкретное место в таблице

Предположим, у нас есть таблица с самыми высокооценёнными сериалами всех времён. Однако у нас есть проблема: «Игра Престолов» обозначена как комедия и нам определённо нужно это изменить:
```
UPDATE tv_series 
SET genre = 'drama' 
WHERE name = 'Game of Thrones';
```